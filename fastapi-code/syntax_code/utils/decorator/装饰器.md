

### 常用修饰关键字
#### wraps
`@wraps(func)` 是 Python 中 `functools` 模块提供的装饰器，它主要用于修饰包装函数，以确保被包装函数的元数据（如函数名、文档字符串等）得到正确传承。具体来说，它的作用如下：
* @wraps(func) 的作用是让 装饰后的函数（wrapper）伪装成原始函数（cal_sum），避免元数据被覆盖。
### 1. 保留函数元数据
- **函数名 (`__name__`)**：包装函数的名字会继承原始函数的名字。
- **文档字符串 (`__doc__`)**：包装函数会继承原始函数的文档字符串。
- **函数签名**：函数的签名（包括参数和返回类型）会被保留，使得包装函数在调用时表现得像原始函数。
- **模块信息 (`__module__`)**：包装函数会继承原始函数所在的模块信息。
- **其他元数据**：如 `__qualname__`、`__doc__` 等，也会被保留。

### 2. 装饰器示例
在没有使用 `@wraps(func)` 时，装饰器会改变包装函数的元数据，使其看起来不像原始函数，这可能会带来调试困难或文档生成问题。使用 `@wraps(func)` 可以避免这个问题。

```python
from functools import wraps

def decorator(func):
    @wraps(func)  # 保留原始函数的元数据
    def wrapper(*args, **kwargs):
        print("Before function call")
        result = func(*args, **kwargs)
        print("After function call")
        return result
    return wrapper

@decorator
def example():
    """This is the original function."""
    print("Inside the function")

# 输出 original function 的元数据
print(example.__name__)  # 输出 'example'
print(example.__doc__)   # 输出 'This is the original function.'
```

### 3. 没有 `@wraps(func)` 的效果
如果没有 `@wraps(func)`，包装函数将会覆盖原始函数的元数据。例如，`example` 的 `__name__` 会变成 `wrapper`，而不是 `example`，这样可能导致难以识别原始函数。

通过使用 `@wraps(func)`，我们能够确保包装函数在继承增强功能的同时，仍然保留原始函数的关键元数据。

简而言之，`@wraps(func)` 的作用是确保装饰器保持被装饰函数的属性不变，使得包装后的函数表现得更像原始函数。