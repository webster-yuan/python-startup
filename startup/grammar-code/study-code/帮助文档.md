在Python中，生成器和装饰器都是通过`def`关键字定义的函数，但它们的功能和行为有很大的不同。编译器通过以下方式区分生成器和普通函数（包括装饰器）：

### 生成器
生成器是通过包含`yield`关键字的函数定义来实现的。`yield`关键字会告诉编译器这个函数是一个生成器函数，而不是一个普通函数。生成器函数在调用时不会执行函数体，而是返回一个生成器对象，这个生成器对象可以在迭代时逐步执行函数体。

```python
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()
print(next(gen))  # 输出 1
print(next(gen))  # 输出 2
print(next(gen))  # 输出 3
```

在这个示例中，`my_generator`函数包含`yield`关键字，因此编译器将其识别为一个生成器函数，并在调用时返回一个生成器对象。

### 装饰器
**装饰器本质上是一个接受函数并返回另一个函数的函数**。它们通常用于修改或扩展其他函数的行为。装饰器本身可以是普通函数，也可以是返回函数的函数。当一个函数被装饰器装饰时，编译器并不会特别对待装饰器函数本身，而是通过装饰器的调用和返回值来修改被装饰的函数。

```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

在这个示例中，`my_decorator`是一个装饰器函数，它返回一个包装函数`wrapper`。当我们使用`@my_decorator`语法装饰`say_hello`函数时，相当于执行了`say_hello = my_decorator(say_hello)`，从而将`say_hello`替换为`wrapper`函数。

### 编译器区分的方式
1. **生成器**：通过`yield`关键字识别。含有`yield`的函数在调用时返回生成器对象。
2. **普通函数和装饰器**：没有`yield`关键字的函数，编译器将其视为普通函数。装饰器是普通函数，但它们的作用是接收其他函数作为参数并返回新函数。

### 示例：区分生成器和装饰器
以下是一个同时包含生成器和装饰器的示例，展示了编译器如何通过不同的方式处理它们：

```python
# 生成器函数
def countdown(n):
    while n > 0:
        yield n
        n -= 1

# 装饰器函数
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Function {func.__name__} finished")
        return result
    return wrapper

# 使用装饰器
@logger
def greet(name):
    print(f"Hello, {name}")

# 使用生成器
gen = countdown(5)
for num in gen:
    print(num)

# 使用装饰器函数
greet("Alice")
```

在这个示例中：
- `countdown`函数包含`yield`关键字，因此被编译器识别为生成器函数。
- `logger`函数是一个装饰器，它接收`greet`函数并返回`wrapper`函数。

通过这些示例，可以清楚地看到编译器如何根据关键字和函数的使用方式来区分生成器和普通函数（包括装饰器）。