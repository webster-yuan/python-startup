### **列表推导式与生成器表达式的语法讲解**

---

### **1. 列表推导式（List Comprehensions）**

#### **语法**：
```python
[表达式 for 变量 in 可迭代对象 if 条件]
```

- **表达式**：生成元素的逻辑。
- **for 变量 in 可迭代对象**：遍历一个可迭代对象。
- **if 条件（可选）**：过滤逻辑，仅满足条件的元素会被添加到结果中。

#### **特点**：
- 用于生成列表。
- 返回值是一个列表。
- 适合处理数据量较小的场景，简洁且易读。

#### **示例**：
```python
# 示例 1：生成平方数列表
squares = [x * x for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 示例 2：过滤偶数并生成它们的平方
even_squares = [x * x for x in range(10) if x % 2 == 0]
print(even_squares)  # [0, 4, 16, 36, 64]
```

---

### **2. 生成器表达式（Generator Expressions）**

#### **语法**：
```python
(表达式 for 变量 in 可迭代对象 if 条件)
```

- **语法与列表推导式非常相似**，唯一区别是使用小括号 `()`。
- 返回值是一个生成器对象，惰性计算（即用到时才生成值）。

#### **特点**：
- 用于生成器（节省内存）。
- 适合处理数据量较大的场景。
- 惰性计算的特性使其效率更高。

#### **示例**：
```python
# 示例 1：生成平方数生成器
squares = (x * x for x in range(10))
print(list(squares))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 示例 2：过滤偶数并生成它们的平方（惰性计算）
even_squares = (x * x for x in range(10) if x % 2 == 0)
print(next(even_squares))  # 0
print(next(even_squares))  # 4
```

---

### **3. 字典推导式（Dictionary Comprehensions）**

#### **语法**：
```python
{key_expr: value_expr for 变量 in 可迭代对象 if 条件}
```

- **key_expr**：生成键的表达式。
- **value_expr**：生成值的表达式。
- **for 变量 in 可迭代对象**：遍历对象。
- **if 条件（可选）**：过滤逻辑。

#### **特点**：
- 用于生成字典。
- 简洁且高效。

#### **示例**：
```python
# 示例 1：生成数字及其平方的字典
squares = {x: x * x for x in range(10)}
print(squares)  # {0: 0, 1: 1, 2: 4, ..., 9: 81}

# 示例 2：过滤偶数键的字典
even_squares = {x: x * x for x in range(10) if x % 2 == 0}
print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
```

---

### **4. 集合推导式（Set Comprehensions）**

#### **语法**：
```python
{表达式 for 变量 in 可迭代对象 if 条件}
```

- 类似于列表推导式，但结果是一个集合（去重）。

#### **特点**：
- 用于生成集合。
- 自动去重，适合需要唯一值的场景。

#### **示例**：
```python
# 示例 1：生成平方数集合
squares = {x * x for x in range(10)}
print(squares)  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 示例 2：生成不重复字符集合
unique_chars = {char.lower() for char in "HelloWorld" if char.isalpha()}
print(unique_chars)  # {'h', 'e', 'l', 'o', 'w', 'r', 'd'}
```

---

### **5. 条件表达式（Ternary Expression）**

#### **语法**：
```python
值1 if 条件 else 值2
```

- **条件为真**时返回 `值1`，否则返回 `值2`。
- 常用于表达式中的简单条件判断。

#### **示例**：
```python
# 示例 1：选择最大值
x, y = 10, 20
max_value = x if x > y else y
print(max_value)  # 20

# 示例 2：列表推导中的条件表达式
result = ["even" if x % 2 == 0 else "odd" for x in range(5)]
print(result)  # ['even', 'odd', 'even', 'odd', 'even']
```

---

### **6. Lambda 表达式（Lambda Expressions）**

#### **语法**：
```python
lambda 参数: 表达式
```

- 匿名函数，适合用于简单的单行逻辑。

#### **特点**：
- 不需要显式定义函数，适用于临时或嵌套操作。

#### **示例**：
```python
# 示例 1：简单的平方函数
square = lambda x: x * x
print(square(5))  # 25

# 示例 2：用于排序
pairs = [(1, 3), (2, 2), (3, 1)]
pairs.sort(key=lambda pair: pair[1])
print(pairs)  # [(3, 1), (2, 2), (1, 3)]
```

---

### **对比总结**

| **类型**              | **语法特点**                                                                                 | **返回类型**     | **适用场景**                              |
|-----------------------|---------------------------------------------------------------------------------------------|------------------|------------------------------------------|
| 列表推导式            | `[表达式 for 变量 in 可迭代对象 if 条件]`                                                    | 列表（`list`）   | 生成列表，适合数据量较小的场景             |
| 生成器表达式          | `(表达式 for 变量 in 可迭代对象 if 条件)`                                                    | 生成器对象       | 惰性计算，适合数据量大的场景             |
| 字典推导式            | `{key_expr: value_expr for 变量 in 可迭代对象 if 条件}`                                       | 字典（`dict`）   | 生成键值对映射                          |
| 集合推导式            | `{表达式 for 变量 in 可迭代对象 if 条件}`                                                    | 集合（`set`）    | 生成去重集合                            |
| 条件表达式            | `值1 if 条件 else 值2`                                                                      | 任意类型         | 简化条件判断                            |
| Lambda 表达式         | `lambda 参数: 表达式`                                                                        | 函数对象         | 定义匿名函数，适合临时逻辑               |

---

### **其他表达式**

#### **生成器函数**
与生成器表达式类似，但通过 `yield` 实现，可以处理更复杂的逻辑。
```python
def generator_function():
    for i in range(5):
        yield i * i

gen = generator_function()
print(list(gen))  # [0, 1, 4, 9, 16]
```

#### **迭代器表达式**
通过手动实现迭代器协议（`__iter__` 和 `__next__`）实现类似功能，但更灵活。

---

这些表达式提供了强大的功能，适用不同的场景，合理使用可以显著提高代码的简洁性和效率。